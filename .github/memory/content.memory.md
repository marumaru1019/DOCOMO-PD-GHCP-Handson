# 作成済みコンテンツ一覧

このファイルは、既に作成済みのコンテンツを記録し、新規コンテンツ作成時の重複を防ぐためのものです。

---

## step15: GitHub Copilot の基礎

### ① チャット機能（example-1.md）
- **チャットビュー**
  - モード早見表（Ask/Edit/Agent の違い）
  - 基本的な使い方（チャットビューの開き方、質問の仕方）
  - コンテキストの追加方法（`#file`, `#selection`, `#codebase`等）
  - リクエストの編集と再試行
  - レスポンスの操作（挿入、コピー、新規ファイル作成）
- **インラインチャット**
  - 呼び出し方法（ショートカット：Mac `⌘I` / Windows `Ctrl+I`）
  - 基本的な使い方（コード選択→指示）
  - 提案の操作（Accept/Discard/再生成）
  - Fix using Copilot（エラー自動修正）
- **練習問題**
  - チャットビューでの質問、コード生成、テスト生成
  - インラインチャットでのリファクタリング、コメント追加

### ② ツール（example-2.md）
- **ツールとは**
  - `#`構文での呼び出し
  - チャット変数の参照
  - Agent mode での自動実行
- **基本ツール一覧（28個）**
  - コンテキスト参照系（`#file`, `#selection`, `#codebase`等）
  - 実行・確認系（`#runTests`, `#runCommands`, `#problems`等）
  - 外部連携系（`#fetch`, `#githubRepo`, `#extensions`等）
- **具体的な使い方（例題3つ）**
  - 例題1：`#terminalSelection` でエラー解決
  - 例題2：`#fetch` で Web ページ情報取得
  - 例題3：`#githubRepo` でライブラリ調査
- **Agent mode でのツール制御**
  - Tool Picker の使い方（🔧アイコン）
  - ツール制限の活用例（セキュリティ重視/効率重視/学習目的）
- **MCP サーバーでツール拡張**
  - MCP とは（Model Context Protocol の説明）
  - 導入メリット（手作業の会話化、再利用性、構成の見える化）
  - インストール方法3つ
    - 方法1：VS Code 拡張機能からインストール
    - 方法2：MCP Marketplace からインストール（プレビュー機能）
    - 方法3：手動で `mcp.json` 編集
  - 例題：Azure MCP Server で Bicep テンプレート作成
    - 拡張機能インストール
    - ツール有効化
    - `#bicepschema` での Bicep テンプレート生成（詳細なコード例含む）
  - その他の活用例（API バージョン確認、スキーマ情報取得）
- **練習問題**
  - 基本ツールの練習
  - エラー解析の練習
  - 情報収集の練習
  - MCP 拡張の練習

### ③ カスタマイズ（example-3.md）
- **カスタマイズとは**
  - 定義と目的（プロジェクト要件への適合、再利用可能なプロンプト管理）
- **カスタマイズの種類（4種類の比較表）**
  - カスタムインストラクション（`.github/copilot-instructions.md`）
  - パス別インストラクション（`.instructions.md`）
  - Prompts ファイル（`.prompt.md`）
  - カスタムチャットモード（`.chatmode.md`）
- **使い分けの指針**
  - Mermaid フローチャート（決定木形式）
  - 常時適用 vs 条件付き vs 手動実行 vs モード選択の判断基準
- **カスタマイズの使い方**
  - **4.1 カスタムインストラクション**
    - 使う場面（プロジェクト全体のルール統一）
    - 作成方法（設定→フォルダ作成→ファイル作成）
    - 含めるべき項目チェックリスト（8項目）
    - 詳細な例（EC サイトフロントエンド、Node.js バックエンド）
    - 自動生成機能の紹介
  - **4.2 パス別インストラクション**
    - 使う場面（領域別のルール適用）
    - 作成方法（コマンドパレット/UI から）
    - Front Matter 設定（`description`, `applyTo`）
    - ファイル構造例
    - glob パターンの使い方
  - **4.3 Prompts ファイル**
    - 使う場面（定型作業の効率化）
    - 作成方法（コマンドパレット/UI から）
    - Front Matter 設定（`mode`, `model`, `description`, `tools`）
    - 呼び出し方法3つ（コマンドパレット/チャット入力/再生ボタン）
    - ツール優先度の説明（Prompt file > chat mode > 既定）
    - 変数使用例（`${file}`等）
  - **4.4 カスタムチャットモード**
    - 使う場面（タスク特化環境）
    - 作成方法（コマンドパレット→保存場所選択）
    - Front Matter 設定（`description`, `tools`, `model`）
    - 例：計画立案モード（詳細な構成付き）
    - チャットモードの管理方法
- **練習問題（3問）**
  - 練習1：カスタムインストラクションの作成
  - 練習2：Prompts ファイルの作成
  - 練習3：カスタムチャットモードの作成
- **よくある質問（4問）**
  - Q1：どれから始めればいい？
  - Q2：ツールの優先順位は？
  - Q3：チームで共有するには？
  - Q4：ワークスペースとユーザープロファイルの違いは？

---

## step16: AI 開発ワークフローを構築する際のポイント

### ① 再現可能で信頼性の高いワークフローの構築（example-1.md）
- **現状の課題**
  - 場当たり的なプロンプト作成の問題点
  - 再現性の欠如と品質のばらつき
- **解決策：3層構造のフレームワーク**
  - Layer 1: Markdown プロンプトエンジニアリング
    - 5つの構成要素（役割、コンテキスト、思考構造、ツール統合、検証ゲート）
  - Layer 2: エージェント・プリミティブ
    - 6種類のプリミティブファイル（.instructions.md, .chatmode.md, .prompt.md, .spec.md, .memory.md, .context.md）
  - Layer 3: コンテキストエンジニアリング
    - セッション分割、コンテキストウィンドウ最適化
- **実践例の比較**
  - Before：単純なプロンプト（問題点の可視化）
  - After：構造化されたプロンプト（改善点の実例）
- **まとめ**
  - 3層の連携効果
  - 次のステップへの導線

### ② 適切なプロンプト設計（example-2.md）
- **プロンプト設計の重要性**
  - 構造化されたプロンプトの効果
- **プロンプト設計の5要素**
  - **3.1 役割の活性化（Role Activation）**
    - 専門的なペルソナ設定
    - 具体例（TypeScript エンジニア）
  - **3.2 コンテキストローディング（Context Loading）**
    - 必要な情報の明示的な提供
    - リンク参照の活用例
  - **3.3 構造化された思考（Structured Thinking）**
    - フェーズ分割とチェックリスト
    - 段階的なタスク実行
  - **3.4 ツール統合（Tool Integration）**
    - ツールの明示的な指定
    - 期待される動作の説明
  - **3.5 バリデーションゲート（Validation Gates）**
    - 承認ポイントの設定
    - 自律性とコントロールのバランス
- **実践例：Todo CLI アプリ作成**
  - セットアップフェーズ
  - コーディング規約の作成（coding_standards.md）
  - アプリケーション実装
  - 実行結果
- **練習問題**
  - 練習1：プロンプトの改善
  - 練習2：独自のプロンプトテンプレート作成
- **まとめ**
  - 5要素の重要性
  - 実践での活用方法

### ③ 再利用可能なコンポーネントの構築（example-3.md）
- **再利用可能なコンポーネントとは**
  - エージェント・プリミティブの概念
  - 自然言語によるプログラミングの基盤
- **エージェント・プリミティブの種類と用途**
  - 6種類のプリミティブ（Mermaid 図解付き）
  - 各プリミティブの特徴（配置場所、トリガー、効果の比較表）
  - VS Code ネイティブサポートについての補足
- **それぞれのプリミティブの具体例**
  - **3.1 Instructions（インストラクション）**
    - TypeScript 開発ガイドライン例
    - 自動適用の効果（Mermaid フロー図）
    - Tips：applyTo パターンの活用
  - **3.2 Chat Mode（チャットモード）**
    - バックエンド開発者モード例
    - チャットモードの使い分け（4つの役割例）
    - ツール制限による境界設定
  - **3.3 Prompt（プロンプト）**
    - コードレビューワークフロー例
    - 5つのフェーズ構成
    - 実行方法
  - **3.4 Spec（仕様書）**
    - 機能仕様テンプレート
    - 8セクション構成（概要、機能要件、技術要件、データ設計等）
    - Spec ファイルの活用フロー（Mermaid 図解）
  - **3.5 Memory（メモリ）**
    - プロジェクトメモリ例
    - 学習記録の構造（セキュリティ、パフォーマンス、API設計）
    - よくある失敗パターンと成功パターン
    - Memory ファイルの効果
  - **3.6 Context（コンテキスト）**
    - API ドキュメント例
    - コンテキストヘルパーの構造
    - 使用方法（リンク参照）
- **練習問題**
  - 練習1：Instructions ファイルの作成
  - 練習2：Chat Mode の設計
  - 練習3：Workflow の自動化
- **まとめ**
  - 6種類のプリミティブの役割
  - 次のステップ（コンテキスト設計）への導線

### ④ コンテキスト設計（セッション分割）（example-4.md）
- **コンテキスト設計とは**
  - コンテキストウィンドウの制限
  - セッション分割の概念
- **なぜセッション分割が必要か**
  - コンテキストウィンドウの制限（Mermaid 図解）
  - セッション分割の効果（比較表）
- **セッション分割の基本戦略**
  - **3.1 開発フェーズによる分割**
    - 新機能開発の例（5セッション構成）
    - セッション1：要件定義
    - セッション2：設計
    - セッション3：実装
    - セッション4：テスト
    - セッション5：ドキュメント
    - 各セッションの詳細なプロンプト例
  - **3.2 タスクの性質による分割**
    - リサーチとアクションの分離例
    - 分離の効果
  - **3.3 複雑さによる分割**
    - モジュール単位の分割例（データモデル、ビジネスロジック、API）
- **セッション間の情報伝達**
  - **4.1 引き継ぎドキュメントの作成**
    - 引き継ぎ方法の例
    - 効果的な引き継ぎのポイント（比較表）
    - 良い引き継ぎ例
- **実践例：セッション分割の完全なワークフロー**
  - バグ修正タスクの5セッション構成
  - セッション1：問題の特定と分析
  - セッション2：修正方針の決定
  - セッション3：修正の実装
  - セッション4：テストの追加
  - セッション5：ドキュメント更新
  - セッション分割の効果（Mermaid フロー図）
- **セッション分割のベストプラクティス**
  - **6.1 いつセッションを分割すべきか**
    - 分割の判断基準（推奨5ケース、不要3ケース）
  - **6.2 セッション分割の落とし穴**
    - よくある問題と解決策（比較表）
- **練習問題**
  - 練習1：基本的なセッション分割
  - 練習2：引き継ぎドキュメントの作成
  - 練習3：セッション分割の最適化
- **まとめ**
  - セッション分割の効果
  - 3つの重要要素の統合
  - 次のステップへの導線

---

## step17: AI 開発ワークフローの実践

### ① マルチリポジトリ環境の構築（example-1.md）
- **マルチリポジトリ環境とは**
  - 定義と必要性（フロントエンド/バックエンドの分離開発）
- **マルチリポジトリ開発の構造**
  - 2つのリポジトリ構成（Frontend: Next.js + React, Backend: FastAPI + Python）
  - ワークスペースの役割（複数リポジトリの統合管理）
- **VS Code でマルチルートワークスペースを設定する**
  - ステップ1：リポジトリのクローン
  - ステップ2：ワークスペースファイルの作成（`.code-workspace`）
  - ステップ3：ワークスペースで開く
  - ワークスペースファイルの設定（folders, settings）
- **ワークスペースインデックスの作成**
  - インデックス作成の重要性
  - 作成方法（Copilot Chat での実行）
  - インデックス状態の確認方法
- **クロスリポジトリでの `#codebase` の活用**
  - マルチリポジトリ環境での `#codebase` の動作
  - 例題：バックエンド型定義をフロントエンドで参照
  - 実践例：API レスポンス型の整合性確認
- **練習問題**
  - 練習1：ワークスペースの作成
  - 練習2：クロスリポジトリ参照の実践
  - 練習3：型定義の整合性確認
- **まとめ**
  - マルチルートワークスペースの効果
  - `#codebase` の横断検索能力
  - 次のステップ（カスタムインストラクション）への導線

### ② カスタムインストラクションの実装（example-2.md）
- **カスタムインストラクションとは**
  - 定義と目的（プロジェクト固有ルールの自動適用）
- **カスタムインストラクションの構造**
  - **2.1 プロジェクトの背景**
    - プロジェクト概要、技術スタック、アーキテクチャ
  - **2.2 コーディング規約**
    - 命名規則、ファイル構造、コーディングスタイル
  - **2.3 開発ワークフロー**
    - ブランチ戦略、コミット規約、レビュープロセス
  - **2.4 参考リソース**
    - 重要なファイルパス、ドキュメントリンク
- **グローバルインストラクションの作成**
  - 例題：社内ヘルプアプリのグローバルインストラクション
  - フロントエンド用（Next.js, TypeScript, shadcn/ui）
  - バックエンド用（FastAPI, Python, PostgreSQL）
  - 各セクションの詳細な構成例
- **モジュラーインストラクションの作成**
  - パス別インストラクションの活用
  - フロントエンド用（`frontend.instructions.md`）
    - TypeScript/React 開発ガイドライン
    - コンポーネント設計、状態管理、スタイリング規約
  - バックエンド用（`backend.instructions.md`）
    - Python/FastAPI 開発ガイドライン
    - API 設計、データベース操作、認証規約
- **Copilot にインストラクション作成を依頼する**
  - 自動生成の手順
  - プロンプト例（プロジェクト情報の提供）
  - 生成結果の確認と調整
- **練習問題**
  - 練習1：グローバルインストラクションの作成
  - 練習2：モジュラーインストラクションの作成
  - 練習3：Copilot による自動生成
- **まとめ**
  - カスタムインストラクションの効果
  - グローバルとモジュラーの使い分け
  - 次のステップ（チャットモード）への導線

### ③ ドメイン特化チャットモードの設計（example-3.md）
- **チャットモードとは**
  - 定義と目的（役割分離とツール境界の設定）
- **なぜチャットモードが必要か**
  - 役割の明確化（4つの比較例）
  - ツール境界の設定（セキュリティと効率性）
- **チャットモードの設計パターン**
  - **3.1 役割ベースのモード設計**
    - Architect Mode の例（設計専門）
    - Engineer Mode の例（実装専門）
    - Reviewer Mode の例（品質保証専門）
  - **3.2 ツールセットの最適化**
    - モード別ツール制限の例（3つのモード比較表）
    - セキュリティ重視の設定例
- **実践例：4つのチャットモードを作成**
  - **例題1: architect（アーキテクト）**
    - 役割：システム設計と仕様策定
    - ツール：codebase, search のみ（編集権限なし）
    - Front Matter 設定例
  - **例題2: frontend-engineer（フロントエンドエンジニア）**
    - 役割：フロントエンド実装
    - ツール：codebase, editFiles, runTests
    - 実装スコープの明確化
  - **例題3: backend-engineer（バックエンドエンジニア）**
    - 役割：バックエンド実装
    - ツール：codebase, editFiles, runTests, runCommands
    - データベース操作の制約
  - **例題4: fullstack-reviewer（フルスタックレビュアー）**
    - 役割：品質検証とレビュー
    - ツール：codebase, changes, runTests, problems
    - 5つのレビュー観点
- **チャットモードの切り替え**
  - UI からの切り替え方法
  - コマンドパレットからの切り替え
  - 状況に応じた使い分け
- **練習問題**
  - 練習1：カスタムチャットモードの作成
  - 練習2：ツールセットの最適化
  - 練習3：モード切り替えの実践
- **まとめ**
  - チャットモードの効果
  - 4つのモードの役割分担
  - 次のステップ（ワークフロー作成）への導線

### ④ エージェントワークフローの作成（example-4.md）
- **エージェントワークフローとは**
  - 定義と目的（再利用可能なタスクテンプレート）
  - 4つのセクション構造（Context Loading / Deterministic Execution / Structured Output / Validation Gate）
  - SDLC の自動化（specify → plan → implement → review）
- **4つのワークフローの設計**
  - ワークフロー一覧表（specify/plan/implement/review の比較）
  - 各ワークフローの責務（Mermaid フロー図）
- **ワークフロー実装例**
  - **例題1: specify.prompt.md（仕様定義ワークフロー）**
    - 役割：ユーザーストーリー形式の仕様書作成
    - Context Loading Phase（3つの事前確認）
    - Deterministic Execution（6ステップ）
      - ユーザーストーリーの抽出
      - 構造化（As a / I want to / So that 形式）
      - 受け入れ条件の定義
      - ユーザーシナリオの作成
      - ビジネス価値の明確化
      - 仕様書の作成
    - Structured Output Requirements（非技術者向けテンプレート）
      - 9セクション構成（概要、ユーザーストーリー、受け入れ条件、シナリオ、UI/UX要件、ビジネス価値、制約、成功指標、参考情報）
    - Human Validation Gate（2段階承認）
    - 使用例（チケット優先度表示機能）
  - **例題2: plan.prompt.md（計画策定ワークフロー）**
    - 役割：実装計画の作成
    - Context Loading Phase（仕様書読み込み、構造把握、依存関係確認）
    - Deterministic Execution（4ステップ）
      - タスクの分解
      - 実装順序の決定
      - リスクの再評価
      - 所要時間の見積もり
    - Structured Output Requirements（チェックリスト形式）
    - Human Validation Gate（2段階承認）
  - **例題3: implement.prompt.md（実装ワークフロー）**
    - 役割：コード実装とテスト作成
    - Context Loading Phase（計画読み込み、構造確認、規約確認、テストパターン確認）
    - Deterministic Execution（6ステップ）
      - 型定義の追加/変更
      - API クライアントの確認/変更
      - コンポーネント/ロジックの実装
      - スタイリングの追加
      - テストの作成
      - テストの実行
    - Structured Output Requirements（実装完了報告）
    - Human Validation Gate（2段階承認）
  - **例題4: review.prompt.md（レビューワークフロー）**
    - 役割：品質検証とレビュー
    - Context Loading Phase（変更確認、仕様確認、テスト結果確認、問題確認、ルール確認）
    - Deterministic Execution（5ステップ）
      - セキュリティレビュー
      - パフォーマンスレビュー
      - アクセシビリティレビュー
      - コード品質レビュー
      - テストカバレッジレビュー
    - Structured Output Requirements（レビューレポート形式）
    - Human Validation Gate（最終承認）
- **ワークフローの呼び出し方法**
  - Copilot Chat から実行（`/specify`, `/plan`, `/implement`, `/review`）
  - VS Code コマンドパレットから実行
  - ファイル内の再生ボタンから実行
- **練習問題**
  - 練習1：カスタムワークフローの作成（debug.prompt.md）
  - 練習2：既存ワークフローの改良（アクセシビリティチェック追加）
  - 練習3：プロジェクト固有のワークフロー設計（deployment.prompt.md）
- **まとめ**
  - エージェントワークフローの効果
  - 4段階 SDLC の標準化
  - 4つの必須セクション
  - 2段階承認プロセス
  - 次のステップ（開発サイクル実践）への導線

### ⑤ 仕様駆動開発サイクルの確立（example-5.md）
- **仕様駆動開発サイクルとは**
  - 定義（.spec.md を起点とした開発プロセス）
  - 4フェーズの連携（specify → plan → implement → review）
  - 知識ベースとしての活用
- **カスタムインストラクション / チャットモード / ワークフローの関係性**
  - **3層アーキテクチャ**
    - カスタムインストラクション（グローバルルール）
    - カスタムチャットモード（役割分離・ツール境界）
    - エージェントワークフロー（タスク手順）
  - 各層の役割と適用範囲（比較表）
  - なぜワークフローが必要か（課題と解決策の比較表）
  - 実例での理解（3層構造の連携）
- **開発サイクルの全体像**
  - 4フェーズの流れ（Mermaid フロー図）
  - 各フェーズの責務と成果物（詳細表）
  - 人間の検証ゲートの配置（2段階ゲートの図解）
- **実践演習: 優先度バッジ機能の追加**
  - 演習の目標（達成基準4項目）
  - **フェーズ1: Specify（仕様定義）**
    - 実行コマンド（`/specify`）
    - 期待される出力
      - Context Loading 完了報告
      - 仕様書の作成（詳細な例）
      - 検証ゲート
    - ユーザー操作（"go" 入力）
    - 承認後の出力
  - **フェーズ2: Plan（計画策定）**
    - 実行コマンド（`/plan`）
    - 期待される出力
      - Context Loading 完了報告
      - 実装計画の作成（詳細な例）
        - 変更ファイル一覧
        - タスク詳細（4タスク）
        - リスク評価
        - 予想所要時間（約30分）
      - 検証ゲート
    - ユーザー操作（"go" 入力）
  - **フェーズ3: Implementation（実装）**
    - 実行コマンド（`/implement`）
    - 期待される動作
      - Context Loading 完了報告
      - 実装の実行（5ステップの詳細）
        - Badge インポート
        - ヘルパー関数作成
        - テーブル更新
        - テスト作成（5テストケース）
        - テスト実行
      - 実装完了報告
      - 検証ゲート
    - ユーザー操作（"go" 入力）
  - **フェーズ4: Review（レビュー）**
    - 実行コマンド（`/review`）
    - 期待される出力
      - Context Loading 完了報告
      - レビュー結果
        - 良い点（4項目）
        - 改善提案（2項目）
        - ブロッカー（なし）
        - 総合評価（条件付き承認）
      - 最終検証ゲート
    - 次のアクション（修正 or 承認）
- **エラー対処とイテレーション**
  - エラー発生時の対処フロー（Mermaid 図解）
  - エラー修正の実例（型エラー、テスト失敗）
  - 修正が必要な場合のイテレーション（フロー図）
- **セッション間の引き継ぎ**
  - セッション分割のベストプラクティス（3セッション構成例）
  - セッション間でのコンテキスト維持（.spec.md の役割）
  - セッション別の追記内容
- **ベストプラクティス**
  - **仕様ファイル（.spec.md）の活用**
    - メリット（5項目）
    - 推奨される管理方法
  - **ワークフロー実行の原則**（5原則）
    - 検証ゲートを必ず通過
    - 小さく分割して実行
    - 仕様ファイルを更新し続ける
    - テストを書いてから承認
    - エラーは即座に対処
  - **並行開発の管理**
    - ブランチごとのワークフロー実行
    - 注意点（3項目）
- **練習問題**
  - 練習1：別の機能を追加（タグフィルター機能）
  - 練習2：エラー対処の体験
  - 練習3：カスタムワークフローの作成
- **まとめ**
  - 仕様駆動開発の効果
  - 4フェーズサイクルの重要性
  - 継続的改善の方法
  - 次のステップ（チーム展開）への導線
